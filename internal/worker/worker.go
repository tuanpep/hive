// Package worker provides the worker pool for parallel task execution.
package worker

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/tuanbt/hive/internal/agent"
	"github.com/tuanbt/hive/internal/config"
	"github.com/tuanbt/hive/internal/task"
)

// TaskResult encapsulates the final outcome of an agent's work on a task.
// It includes generated code, status, errors, and any new sub-tasks
// discovered during the planning phase.
type TaskResult struct {
	Task     *task.Task
	Status   task.Status
	Output   string
	Error    error
	WorkerID int
	Duration time.Duration
	NewTasks []*task.Task // Sub-tasks generated by the agent
}

// Worker is a single execution thread that manages an autonomous agent.
// It handles the task lifecycle: loading context, implementation, and review.
type Worker struct {
	ID         int
	agent      *agent.Driver
	taskChan   <-chan *task.Task
	resultChan chan<- *TaskResult
	config     *config.Config
	logger     *slog.Logger
	workDir    string
}

// New initializes a new Worker with its own ID and communication channels.
func New(id int, cfg *config.Config, taskChan <-chan *task.Task,
	resultChan chan<- *TaskResult, logger *slog.Logger, workDir string) *Worker {
	return &Worker{
		ID:         id,
		taskChan:   taskChan,
		resultChan: resultChan,
		config:     cfg,
		logger:     logger.With("worker_id", id),
		workDir:    workDir,
	}
}

// Start begins processing tasks from the task channel.
// Blocks until context is cancelled or task channel is closed.
func (w *Worker) Start(ctx context.Context) error {
	w.logger.Info("worker starting")

	// Create agent driver
	w.agent = agent.New(w.config, w.logger, w.workDir)
	if err := w.agent.Start(); err != nil {
		return fmt.Errorf("failed to start agent: %w", err)
	}

	// Wait for agent to initialize
	time.Sleep(500 * time.Millisecond)
	w.agent.DrainOutput(time.Second)

	w.logger.Info("worker ready, waiting for tasks")

	// Process tasks
	for {
		select {
		case <-ctx.Done():
			w.logger.Info("worker stopping due to context cancellation")
			w.agent.Stop()
			return ctx.Err()

		case t, ok := <-w.taskChan:
			if !ok {
				w.logger.Info("task channel closed, worker stopping")
				w.agent.Stop()
				return nil
			}

			result := w.processTask(ctx, t)

			// Send result (non-blocking with timeout)
			select {
			case w.resultChan <- result:
			case <-time.After(5 * time.Second):
				w.logger.Error("failed to send result, channel blocked")
			}
		}
	}
}

// processTask handles a single task through all phases.
func (w *Worker) processTask(ctx context.Context, t *task.Task) *TaskResult {
	startTime := time.Now()
	w.logger.Info("processing task", "task_id", t.ID, "title", t.Title)

	// Create task-level timeout context
	taskCtx, cancel := context.WithTimeout(ctx, time.Duration(w.config.MaxTaskDurationSeconds)*time.Second)
	defer cancel()

	// Open task log file
	logPath := filepath.Join(w.config.LogDirectory, fmt.Sprintf("%s.log", t.ID))
	logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		w.logger.Error("failed to open task log file", "path", logPath, "error", err)
	} else {
		defer logFile.Close()
	}

	// Ensure agent is alive
	if err := w.agent.EnsureAlive(); err != nil {
		return &TaskResult{
			Task:     t,
			Status:   task.StatusFailed,
			Error:    fmt.Errorf("agent not available: %w", err),
			WorkerID: w.ID,
			Duration: time.Since(startTime),
		}
	}

	// Phase 1: Load context files
	if len(t.ContextFiles) > 0 {
		w.logger.Debug("loading context files", "count", len(t.ContextFiles))
		for _, file := range t.ContextFiles {
			if err := w.agent.SendInput(fmt.Sprintf("/add %s", file)); err != nil {
				w.logger.Error("failed to load context file", "file", file, "error", err)
			}
			// Wait briefly for each file to load
			w.agent.WaitForResponse(taskCtx, logFile)
		}
	}

	// Phase 2: Implementation
	w.logger.Debug("sending implementation prompt")

	// Construct instructions
	var instructions strings.Builder
	instructions.WriteString("=== SYSTEM INSTRUCTIONS ===\n")
	for _, rule := range w.config.Instructions.GlobalRules {
		instructions.WriteString("- " + rule + "\n")
	}
	if t.Role != "" {
		if roleRule, ok := w.config.Instructions.RoleInstructions[t.Role]; ok {
			instructions.WriteString("\n=== ROLE: " + strings.ToUpper(t.Role) + " ===\n")
			instructions.WriteString(roleRule + "\n")
		}
	}
	instructions.WriteString("\n=== TASK ===\n")

	implPrompt := fmt.Sprintf(`%sTask: %s
Description: %s
Please implement this now. When you are finished, output '%s'.`,
		instructions.String(), t.Title, t.Description, w.config.CompletionMarker)

	if err := w.agent.SendInput(implPrompt); err != nil {
		return &TaskResult{
			Task:     t,
			Status:   task.StatusFailed,
			Error:    fmt.Errorf("failed to send implementation prompt: %w", err),
			WorkerID: w.ID,
			Duration: time.Since(startTime),
		}
	}

	implOutput, implMarkerFound, err := w.agent.WaitForResponse(taskCtx, logFile)
	if err != nil {
		return &TaskResult{
			Task:     t,
			Status:   task.StatusFailed,
			Output:   implOutput,
			Error:    fmt.Errorf("implementation phase failed: %w", err),
			WorkerID: w.ID,
			Duration: time.Since(startTime),
		}
	}

	if !implMarkerFound {
		w.logger.Warn("implementation phase completed without marker (silence timeout)")
	}

	// Phase 3: Review with retries
	w.logger.Debug("starting review phase")
	reviewPrompt := fmt.Sprintf(`Review the implementation:
1. Run any tests if possible
2. Fix any syntax errors
3. If everything is correct, say '%s'`,
		w.config.CompletionMarker)

	var reviewOutput string
	reviewSuccess := false

	for attempt := 1; attempt <= w.config.MaxReviewCycles; attempt++ {
		w.logger.Debug("review attempt", "attempt", attempt, "max", w.config.MaxReviewCycles)

		if err := w.agent.SendInput(reviewPrompt); err != nil {
			w.logger.Error("failed to send review prompt", "error", err)
			continue
		}

		output, markerFound, err := w.agent.WaitForResponse(taskCtx, logFile)
		reviewOutput = output

		if err != nil {
			if taskCtx.Err() != nil {
				// Context cancelled/timeout
				return &TaskResult{
					Task:     t,
					Status:   task.StatusFailed,
					Output:   implOutput + "\n---\n" + reviewOutput,
					Error:    fmt.Errorf("task timeout during review: %w", err),
					WorkerID: w.ID,
					Duration: time.Since(startTime),
				}
			}
			w.logger.Warn("review attempt failed", "attempt", attempt, "error", err)
			continue
		}

		if markerFound {
			reviewSuccess = true
			w.logger.Info("review completed successfully", "attempt", attempt)
			break
		}

		// Check if output indicates success even without marker
		if strings.Contains(strings.ToLower(output), "success") ||
			strings.Contains(strings.ToLower(output), "passed") {
			reviewSuccess = true
			w.logger.Info("review indicates success", "attempt", attempt)
			break
		}

		w.logger.Warn("review attempt did not find completion marker", "attempt", attempt)
	}

	// Determine final status
	finalStatus := task.StatusFailed
	var finalError error

	if reviewSuccess {
		finalStatus = task.StatusCompleted
		w.agent.ResetRestartCount() // Reset on success
	} else {
		finalError = fmt.Errorf("review failed after %d attempts", w.config.MaxReviewCycles)
	}

	// Clear context for next task
	w.agent.SendInput("/clear")
	w.agent.DrainOutput(time.Second)

	fullOutput := implOutput + "\n---\n" + reviewOutput
	var newTasks []*task.Task

	// Auto-Planning: Check for ### PLAN_START ### ... ### PLAN_END ###
	if strings.Contains(fullOutput, "### PLAN_START ###") && strings.Contains(fullOutput, "### PLAN_END ###") {
		startIdx := strings.Index(fullOutput, "### PLAN_START ###")
		endIdx := strings.Index(fullOutput, "### PLAN_END ###")
		if startIdx < endIdx {
			jsonStr := strings.TrimSpace(fullOutput[startIdx+18 : endIdx]) // 18 = len("### PLAN_START ###")
			// Remove potential markdown code blocks
			jsonStr = strings.TrimPrefix(jsonStr, "```json")
			jsonStr = strings.TrimPrefix(jsonStr, "```")
			jsonStr = strings.TrimSuffix(jsonStr, "```")

			// Use a temporary struct for unmarshalling
			var rawTasks []struct {
				Title       string `json:"title"`
				Description string `json:"description"`
				Role        string `json:"role"`
			}

			if err := json.Unmarshal([]byte(jsonStr), &rawTasks); err != nil {
				w.logger.Error("failed to unmarshal auto-plan", "error", err)
				finalStatus = task.StatusFailed // Fail task if plan is invalid? Optional.
				finalError = fmt.Errorf("invalid plan JSON format: %w", err)
			} else {
				w.logger.Info("extracted new tasks from plan", "count", len(rawTasks))
				for _, rt := range rawTasks {
					// Generate unique ID for subtask
					subID := fmt.Sprintf("task-%d", time.Now().UnixNano())
					nt := task.NewTask(subID, rt.Title, rt.Description)
					nt.Role = rt.Role
					newTasks = append(newTasks, nt)
					// Small sleep to ensure unique timestamps if multiple tasks
					time.Sleep(time.Millisecond)
				}
			}
		}
	}

	return &TaskResult{
		Task:     t,
		Status:   finalStatus,
		Output:   fullOutput,
		Error:    finalError,
		WorkerID: w.ID,
		Duration: time.Since(startTime),
		NewTasks: newTasks,
	}
}
